from Crypto.Util.number import *
import gmpy2

# flag = b'NSSCTF{******}'

# p = getPrime(512)
# q = gmpy2.next_prime(p - getPrime(256))
# n = p*q
# e = 65537
# phi = (p-1)*(q-1)
# m = bytes_to_long(flag)
# c = pow(m, e, n)

# print(f'n = {n}')
# print(f'e = {e}')
# print(f'c = {c}')
import gmpy2

n = 148841588941490812589697505975986386226158446072049530534135525236572105309550985274214825612079495930267744452266230141871521931612761645600600201983605957650711248808703757693378777706453580124982526368706977258199152469200838211055230241296139605912607613807871432800586045262879581100319519318390454452117
e = 65537
c = 69038543593219231496623016705860610154255535760819426453485115089535439537440188692852514795648297200067103841434646958466720891016026061658602312900242658759575613625726750416539176437174502082858413122020981274672260498423684555063381678387696096811975800995242962853092582362805345713900308205654744774932


def check(x):
    res = gmpy2.iroot(pow(x, 2) - n if pow(x, 2) - n > 0 else 3, 2)
    if res[1]:
        return res[0]
    return 0


init = gmpy2.isqrt(n)
while True:
    p_sub_q = check(init) * 2
    if p_sub_q:
        p_add_q = init * 2
        break
    init += 1

p = (p_sub_q + p_add_q) // 2
q = n // p
phi = (p - 1) * (q - 1)
d = inverse(e, phi)
m = pow(c, d, n)
print(long_to_bytes(m))
